[variables]
main_domain = "${domain}"

[[config.domains]]
serviceName = "nginx"
port = 80
host = "${main_domain}"

[config]
env = [
'################################################################################',
'## COMMONLY MODIFIED CONFIGURATIONS',
'################################################################################',
'## Version of Onyx to deploy, default is latest (main built nightly)',
'## For Craft support, use: IMAGE_TAG=craft-latest',
'IMAGE_TAG=latest',
'',
'## Onyx Craft Configuration',
'## Craft enables AI-powered web app building within Onyx (disabled by default)',
'## To enable Craft, uncomment the lines below (and comment out the above)',
'## or use --include-craft with the install script',
'## This adds Node.js 20 and opencode CLI to the image at build time',
'# ENABLE_CRAFT=true',
'# IMAGE_TAG=craft-latest',
'',
'## Auth Settings',
'### https://docs.onyx.app/deployment/authentication',
'AUTH_TYPE=disabled',
'# SESSION_EXPIRE_TIME_SECONDS=',
'### Recommend to set this for security',
'# ENCRYPTION_KEY_SECRET=',
'### Optional',
'# API_KEY_HASH_ROUNDS=',
'### You can add a comma separated list of domains like onyx.app, only those domains will be allowed to signup/log in',
'# VALID_EMAIL_DOMAINS=',
'',
'## Chat Configuration',
'# HARD_DELETE_CHATS=',
'',
'## Base URL for redirects',
'# WEB_DOMAIN=',
'',
'## Enterprise Features, requires a paid plan and licenses',
'ENABLE_PAID_ENTERPRISE_EDITION_FEATURES=false',
'',
'## User File Upload Configuration',
'# Skip the token count threshold check (100,000 tokens) for uploaded files',
'# For self-hosted: set to true to skip for all users',
'# SKIP_USERFILE_THRESHOLD=false',
'# For multi-tenant: comma-separated list of tenant IDs to skip threshold',
'# SKIP_USERFILE_THRESHOLD_TENANT_IDS=',
'',
'',
'################################################################################',
'## SERVICES CONFIGURATIONS',
'################################################################################',
'## Database Configuration',
'POSTGRES_USER=postgres',
'POSTGRES_PASSWORD=password',
'# POSTGRES_DB=',
'# POSTGRES_DEFAULT_SCHEMA=',
'# POSTGRES_USE_NULL_POOL=',
'# POSTGRES_API_SERVER_POOL_SIZE=',
'# POSTGRES_API_SERVER_POOL_OVERFLOW',
'# POSTGRES_IDLE_SESSIONS_TIMEOUT=',
'# POSTGRES_POOL_RECYCLE=',
'# DB_READONLY_USER=',
'# DB_READONLY_PASSWORD=',
'',
'## File Store Backend: "s3" (default, uses MinIO) or "postgres" (no extra services needed)',
'## COMPOSE_PROFILES activates the MinIO service. To use PostgreSQL file storage instead,',
'## comment out COMPOSE_PROFILES and set FILE_STORE_BACKEND=postgres.',
'COMPOSE_PROFILES=s3-filestore',
'FILE_STORE_BACKEND=s3',
'',
'## MinIO/S3 Configuration (only needed when FILE_STORE_BACKEND=s3)',
'S3_ENDPOINT_URL=http://minio:9000',
'S3_AWS_ACCESS_KEY_ID=minioadmin',
'S3_AWS_SECRET_ACCESS_KEY=minioadmin',
'S3_FILE_STORE_BUCKET_NAME=onyx-file-store-bucket',
'MINIO_ROOT_USER=minioadmin',
'MINIO_ROOT_PASSWORD=minioadmin',
'',
'## Nginx Proxy Timeout Configuration (in seconds)',
'## These settings control how long nginx waits for upstream servers (api_server/web_server)',
'## Increase these values if you experience timeout errors with long-running requests',
'# NGINX_PROXY_CONNECT_TIMEOUT=300',
'# NGINX_PROXY_SEND_TIMEOUT=300',
'# NGINX_PROXY_READ_TIMEOUT=300',
'',
'## MCP Server Configuration',
'## The MCP (Model Context Protocol) server allows external MCP clients to interact with Onyx',
'## Set to true to enable the MCP server (disabled by default)',
'# MCP_SERVER_ENABLED=false',
'## Port for the MCP server (defaults to 8090)',
'# MCP_SERVER_PORT=8090',
'## CORS origins for MCP clients (comma-separated list)',
'# MCP_SERVER_CORS_ORIGINS=',
'',
'## Discord Bot Configuration',
'## The Discord bot allows users to interact with Onyx from Discord servers',
'## Bot token from Discord Developer Portal (required to enable the bot)',
'# DISCORD_BOT_TOKEN=',
'## Command prefix for bot commands (default: "!")',
'# DISCORD_BOT_INVOKE_CHAR=!',
'',
'## Celery Configuration',
'# CELERY_BROKER_POOL_LIMIT=',
'# CELERY_WORKER_DOCFETCHING_CONCURRENCY=',
'# CELERY_WORKER_DOCPROCESSING_CONCURRENCY=',
'# CELERY_WORKER_LIGHT_CONCURRENCY=',
'# CELERY_WORKER_LIGHT_PREFETCH_MULTIPLIER=',
'',
'## AWS Configuration',
'# AWS_ACCESS_KEY_ID=',
'# AWS_SECRET_ACCESS_KEY=',
'# AWS_REGION_NAME=',
'# Set to true when using IAM authentication for Postgres connections.',
'USE_IAM_AUTH=false',
'',
'',
'################################################################################',
'## DEVELOPER, DEBUGGING, AND LOGGING',
'################################################################################',
'## Logging and Telemetry',
'LOG_LEVEL=info',
'LOG_ONYX_MODEL_INTERACTIONS=False',
'# LOG_VESPA_TIMING_INFORMATION=',
'# LOG_ENDPOINT_LATENCY=',
'# LOG_POSTGRES_LATENCY=',
'# LOG_POSTGRES_CONN_COUNTS=',
'# DISABLE_TELEMETRY=',
'',
'## Feature Flags',
'# SHOW_EXTRA_CONNECTORS=true',
'# DISABLE_MODEL_SERVER=false',
'',
'## Analytics',
'# SENTRY_DSN=',
'',
'## Demo/Testing',
'# MOCK_CONNECTOR_FILE_PATH=',
'',
'',
'################################################################################',
'## ADVANCED CONFIGURATIONS',
'################################################################################',
'## SlackBot Configuration',
'# ONYX_BOT_DISABLE_DOCS_ONLY_ANSWER=',
'# ONYX_BOT_FEEDBACK_VISIBILITY=',
'# ONYX_BOT_DISPLAY_ERROR_MSGS=',
'# NOTIFY_SLACKBOT_NO_ANSWER=',
'# ONYX_BOT_MAX_QPM=',
'# ONYX_BOT_MAX_WAIT_TIME=',
'',
'## Advanced Auth Settings',
'# GOOGLE_OAUTH_CLIENT_ID=',
'# GOOGLE_OAUTH_CLIENT_SECRET=',
'# REQUIRE_EMAIL_VERIFICATION=',
'# SMTP_SERVER=',
'# SMTP_PORT=',
'# SMTP_USER=',
'# SMTP_PASS=',
'# ENABLE_EMAIL_INVITES=',
'# EMAIL_FROM=',
'# OAUTH_CLIENT_ID=',
'# OAUTH_CLIENT_SECRET=',
'# OPENID_CONFIG_URL=',
'# TRACK_EXTERNAL_IDP_EXPIRY=',
'# CORS_ALLOWED_ORIGIN=',
'# INTEGRATION_TESTS_MODE=',
'# JWT_PUBLIC_KEY_URL=',
'',
'## Gen AI Settings',
'# GEN_AI_MAX_TOKENS=',
'# LLM_SOCKET_READ_TIMEOUT=',
'# MAX_CHUNKS_FED_TO_CHAT=',
'# DISABLE_LITELLM_STREAMING=',
'# LITELLM_EXTRA_HEADERS=',
'# GEN_AI_API_KEY=',
'# GENERATIVE_MODEL_ACCESS_CHECK_FREQ=',
'# LITELLM_CUSTOM_ERROR_MESSAGE_MAPPINGS=',
'',
'## Query Options',
'# DOC_TIME_DECAY=',
'# HYBRID_ALPHA=',
'# EDIT_KEYWORD_QUERY=',
'# USE_SEMANTIC_KEYWORD_EXPANSIONS_BASIC_SEARCH=',
'',
'## Model Configuration',
'# EMBEDDING_BATCH_SIZE=',
'# DOCUMENT_ENCODER_MODEL=',
'# DOC_EMBEDDING_DIM=',
'# NORMALIZE_EMBEDDINGS=',
'# ASYM_QUERY_PREFIX=',
'# ASYM_PASSAGE_PREFIX=',
'# DISABLE_RERANK_FOR_STREAMING=',
'# MODEL_SERVER_PORT=',
'# INDEX_BATCH_SIZE=',
'# MIN_THREADS_ML_MODELS=',
'# CLIENT_EMBEDDING_TIMEOUT=',
'',
'## Indexing Configuration',
'# VESPA_SEARCHER_THREADS=',
'# ENABLED_CONNECTOR_TYPES=',
'# DISABLE_INDEX_UPDATE_ON_SWAP=',
'# CONTINUE_ON_CONNECTOR_FAILURE=',
'# CONFLUENCE_CONNECTOR_LABELS_TO_SKIP=',
'# JIRA_CONNECTOR_LABELS_TO_SKIP=',
'# WEB_CONNECTOR_VALIDATE_URLS=',
'# JIRA_SERVER_API_VERSION=',
'# JIRA_CLOUD_API_VERSION=',
'# GONG_CONNECTOR_START_TIME=',
'# NOTION_CONNECTOR_ENABLE_RECURSIVE_PAGE_LOOKUP=',
'# GITHUB_CONNECTOR_BASE_URL=',
'# MAX_DOCUMENT_CHARS=',
'# MAX_FILE_SIZE_BYTES=',
'',
'## OAuth Connector Configs',
'# EGNYTE_CLIENT_ID=',
'# EGNYTE_CLIENT_SECRET=',
'# EGNYTE_LOCALHOST_OVERRIDE=',
'# LINEAR_CLIENT_ID=',
'# LINEAR_CLIENT_SECRET=',
'',
'## Miscellaneous',
'# ONYX_QUERY_HISTORY_TYPE=',
'# CHECK_TTL_MANAGEMENT_TASK_FREQUENCY_IN_HOURS=',
'# VESPA_LANGUAGE_OVERRIDE=',
'',
'## Frontend Configs',
'# THEME_IS_DARK=',
'# NEXT_PUBLIC_DISABLE_LOGOUT=',
'# NEXT_PUBLIC_FORGOT_PASSWORD_ENABLED=',
'# NEXT_PUBLIC_THEME=',
'# NEXT_PUBLIC_DO_NOT_USE_TOGGLE_OFF_DANSWER_POWERED=',
'# NEXT_PUBLIC_CUSTOM_REFRESH_URL=',
'',
'## Pointer to services',
'POSTGRES_HOST=relational_db',
'VESPA_HOST=index',
'REDIS_HOST=cache',
'MODEL_SERVER_HOST=inference_model_server',
'INDEXING_MODEL_SERVER_HOST=indexing_model_server',
'INTERNAL_URL=http://api_server:8080']

[[config.mounts]]
filePath = "/volumes/data/nginx/app.conf.template"
content = """
# Log format to include request latency
log_format custom_main '$remote_addr - $remote_user [$time_local] "$request" '
                '$status $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for" '
                'rt=$request_time';

upstream api_server {
    # fail_timeout=0 means we always retry an upstream even if it failed
    # to return a good HTTP response

    # for UNIX domain socket setups
    #server unix:/tmp/gunicorn.sock fail_timeout=0;

    # for a TCP configuration
    # TODO: use gunicorn to manage multiple processes
    server ${ONYX_BACKEND_API_HOST}:8080 fail_timeout=0;
}

upstream web_server {
    server ${ONYX_WEB_SERVER_HOST}:3000 fail_timeout=0;
}

# Conditionally include MCP upstream configuration
include /etc/nginx/conf.d/mcp_upstream.conf.inc;

server {
    listen 80 default_server;

    client_max_body_size 5G;    # Maximum upload size

    access_log /var/log/nginx/access.log custom_main;

    # Conditionally include MCP location configuration
    include /etc/nginx/conf.d/mcp.conf.inc;

    # Match both /api/* and /openapi.json in a single rule
    location ~ ^/(api|openapi.json)(/.*)?$ {
        # Rewrite /api prefixed matched paths
        rewrite ^/api(/.*)$ $1 break;

        # misc headers
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        proxy_set_header Host $host;

        # need to use 1.1 to support chunked transfers
        proxy_http_version 1.1;
        proxy_buffering off;

        # timeout settings
        proxy_connect_timeout ${NGINX_PROXY_CONNECT_TIMEOUT}s;
        proxy_send_timeout ${NGINX_PROXY_SEND_TIMEOUT}s;
        proxy_read_timeout ${NGINX_PROXY_READ_TIMEOUT}s;

        # we don't want nginx trying to do something clever with
        # redirects, we set the Host: header above already.
        proxy_redirect off;
        proxy_pass http://api_server;
    }

    location / {
        # misc headers
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        proxy_set_header Host $host;

        proxy_http_version 1.1;

        # timeout settings
        proxy_connect_timeout ${NGINX_PROXY_CONNECT_TIMEOUT}s;
        proxy_send_timeout ${NGINX_PROXY_SEND_TIMEOUT}s;
        proxy_read_timeout ${NGINX_PROXY_READ_TIMEOUT}s;

        # we don't want nginx trying to do something clever with
        # redirects, we set the Host: header above already.
        proxy_redirect off;
        proxy_pass http://web_server;
    }

}
"""

[[config.mounts]]
filePath = "/volumes/data/nginx/mcp.conf.inc.template"
content = """
# MCP Server - Model Context Protocol for LLM integrations
# Match /mcp, /mcp/, or /mcp/* but NOT /mcpserver, /mcpapi, etc.
location ~ ^/mcp(/.*)?$ {
    # misc headers
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header Host $host;

    # Standard HTTP 1.1
    proxy_http_version 1.1;

    # Timeouts for MCP requests
    proxy_connect_timeout 30s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;

    proxy_redirect off;
    rewrite ^/mcp(/.*)$ $1 break;
    rewrite ^/mcp/?$ / break;
    proxy_pass http://mcp_server;
}
"""

[[config.mounts]]
filePath = "/volumes/data/nginx/mcp_upstream.conf.inc.template"
content = """
upstream mcp_server {
    server ${ONYX_MCP_SERVER_HOST}:8090 fail_timeout=0;
}
"""

[[config.mounts]]
filePath = "/volumes/data/nginx/run-nginx.sh"
content = """
# fill in the template
export ONYX_BACKEND_API_HOST="${ONYX_BACKEND_API_HOST:-api_server}"
export ONYX_WEB_SERVER_HOST="${ONYX_WEB_SERVER_HOST:-web_server}"
export ONYX_MCP_SERVER_HOST="${ONYX_MCP_SERVER_HOST:-mcp_server}"

export SSL_CERT_FILE_NAME="${SSL_CERT_FILE_NAME:-ssl.crt}"
export SSL_CERT_KEY_FILE_NAME="${SSL_CERT_KEY_FILE_NAME:-ssl.key}"

# Nginx timeout settings (in seconds)
export NGINX_PROXY_CONNECT_TIMEOUT="${NGINX_PROXY_CONNECT_TIMEOUT:-300}"
export NGINX_PROXY_SEND_TIMEOUT="${NGINX_PROXY_SEND_TIMEOUT:-300}"
export NGINX_PROXY_READ_TIMEOUT="${NGINX_PROXY_READ_TIMEOUT:-300}"

echo "Using API server host: $ONYX_BACKEND_API_HOST"
echo "Using web server host: $ONYX_WEB_SERVER_HOST"
echo "Using MCP server host: $ONYX_MCP_SERVER_HOST"
echo "Using nginx proxy timeouts - connect: ${NGINX_PROXY_CONNECT_TIMEOUT}s, send: ${NGINX_PROXY_SEND_TIMEOUT}s, read: ${NGINX_PROXY_READ_TIMEOUT}s"

envsubst '$DOMAIN $SSL_CERT_FILE_NAME $SSL_CERT_KEY_FILE_NAME $ONYX_BACKEND_API_HOST $ONYX_WEB_SERVER_HOST $ONYX_MCP_SERVER_HOST $NGINX_PROXY_CONNECT_TIMEOUT $NGINX_PROXY_SEND_TIMEOUT $NGINX_PROXY_READ_TIMEOUT' < "/etc/nginx/conf.d/$1" > /etc/nginx/conf.d/app.conf

# Conditionally create MCP server configuration
if [ "${MCP_SERVER_ENABLED}" = "True" ] || [ "${MCP_SERVER_ENABLED}" = "true" ]; then
  echo "MCP server is enabled, creating MCP configuration..."
  envsubst '$ONYX_MCP_SERVER_HOST' < "/etc/nginx/conf.d/mcp_upstream.conf.inc.template" > /etc/nginx/conf.d/mcp_upstream.conf.inc
  envsubst '$ONYX_MCP_SERVER_HOST' < "/etc/nginx/conf.d/mcp.conf.inc.template" > /etc/nginx/conf.d/mcp.conf.inc
else
  echo "MCP server is disabled, removing MCP configuration..."
  # Leave empty placeholder files so nginx includes do not fail
  # These files are empty because MCP server is disabled
  echo "# Empty file - MCP server is disabled" > /etc/nginx/conf.d/mcp_upstream.conf.inc
  echo "# Empty file - MCP server is disabled" > /etc/nginx/conf.d/mcp.conf.inc
fi

# wait for the api_server to be ready
echo "Waiting for API server to boot up; this may take a minute or two..."
echo "If this takes more than ~5 minutes, check the logs of the API server container for errors with the following command:"
echo
echo "docker logs onyx-api_server-1"
echo

while true; do
  # Use curl to send a request and capture the HTTP status code
  status_code=$(curl -o /dev/null -s -w "%{http_code}\n" "http://${ONYX_BACKEND_API_HOST}:8080/health")
  
  # Check if the status code is 200
  if [ "$status_code" -eq 200 ]; then
    echo "API server responded with 200, starting nginx..."
    break  # Exit the loop
  else
    echo "API server responded with $status_code, retrying in 5 seconds..."
    sleep 5  # Sleep for 5 seconds before retrying
  fi
done

# Start nginx and reload every 6 hours
while :; do sleep 6h & wait; nginx -s reload; done & nginx -g "daemon off;"
"""
